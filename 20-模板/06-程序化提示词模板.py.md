## 1）整体概要

该代码段提供了一个名为 **"Prompt Program Template"** 的创新框架，旨在通过\*\*结构化、可编程的指令\*\*来引导大型语言模型（LLM）的复杂推理过程。它将自然语言的灵活性与传统编程构造的严谨性结合起来，创建了一种新的“提示编程”范式。

其核心思想是将发送给 LLM 的提示（Prompt）不仅仅视为一段文本，而是一个具备：

1. **模块化组件**：将提示分解为可重用的独立步骤。

2. **控制流**：支持条件判断（`IF/ELSE`）和循环（`FOR EACH`）逻辑。

3) **变量管理**：允许在提示内部定义和更新变量，以跟踪上下文状态。

4) **显式推理步骤**：强制 LLM 按照明确的、分步的指令进行思考和操作。

5. **错误处理与回退逻辑**：定义当 LLM 执行过程中遇到问题时的应对策略。

6. **与神经场集成**：支持将提示内容和执行过程融入到动态的“神经场”上下文中，实现更高级的记忆、共振和信息持久化。

7) **与协议壳集成**：能够解析并执行基于特定领域语言（如 Pareto-lang）定义的“协议壳”，将结构化的任务定义转化为 LLM 可理解和执行的程序。



## 2）模块说明

该代码段主要由一系列类和枚举构成，共同实现了提示程序的核心功能及其扩展集成：

* **`StepType` (枚举类)**

  * **作用**：定义了提示程序中每一步的类型，用于标记该步骤的语义和行为。

  * **类型**：

    * `INSTRUCTION`：基本指令。

    * `CONDITION`：条件分支（`IF`语句）。

    * `LOOP`：循环（`FOR EACH`语句）。

    * `VARIABLE`：变量赋值。

    * `FUNCTION`：函数调用。

    * `ERROR`：错误处理指令。

  * **工程关系**：提供了构建结构化提示的原子单元，是 `ProgramStep` 的基础。



* **`ProgramStep` (类)**

  * **作用**：表示提示程序中的一个独立步骤。

  * **核心属性**：

    * `content`：步骤的具体文本内容或表达式。

    * `step_type`：该步骤的类型（来自 `StepType`）。

    * `metadata`：存储与步骤类型相关的额外信息，如条件表达式、变量名、函数名等。

    * `substeps`：一个列表，用于存储嵌套的子步骤（例如，条件语句的 `then` 块或循环的 `body`）。

  * **核心方法**：

    * `add_substep(substep)`：向当前步骤添加一个子步骤。

    * `format(index, indent)`：将步骤格式化为带有编号和缩进的字符串，使其在 LLM 提示中呈现为清晰的程序结构。

  * **工程关系**：是组成 `PromptProgram` 的基本构建块，定义了单个指令或逻辑单元的表示方式。



* **`PromptProgram` (类)**

  * **作用**：是提示程序的核心管理器，负责程序的构建、格式化和执行逻辑。

  * **核心属性**：

    * `description`：程序的描述。

    * `model`：与程序交互的 LLM 接口实例（例如，一个 `MockModel` 或真实的 LLM 客户端）。

    * `variables`：程序运行时可用的变量字典。

    * `neural_field`：可选的神经场实例，用于上下文的持久化和动态管理。

    * `steps`：一个 `ProgramStep` 对象的列表，代表程序的主体逻辑。

    * `error_handlers`：一个 `ProgramStep` 对象的列表，定义了错误发生时的处理指令。

    * `execution_trace`：记录程序每次执行的详细轨迹。

  * **核心方法**：

    * `add_step(...)`, `add_condition(...)`, `add_loop(...)`, `add_variable(...)`, `add_function(...)`, `add_error_handler(...)`：一系列工厂方法，用于便捷地向程序中添加不同类型的 `ProgramStep`。

    * `format()`：将整个 `PromptProgram` 对象（包括描述、所有步骤、错误处理器和初始变量）格式化为发送给 LLM 的完整提示字符串。

    * `execute(input_data, max_tokens)`：核心执行方法。它根据是否存在 `neural_field` 来构建包含动态上下文的提示，然后调用 `self.model.generate()` 来获取 LLM 的响应。它还包含了基本的错误捕获和回退到错误处理器的逻辑。

    * `_create_standard_prompt()`：当没有神经场集成时，生成标准提示的辅助方法。

    * `execute_with_trace()`：执行程序并解析 LLM 响应，以返回结构化的执行轨迹。

    * `_parse_execution_trace()`：从 LLM 的原始响应文本中解析出分步执行的推理和结果。

  * **工程关系**：提供了构建、管理和执行 LLM 指导程序的核心能力，是整个框架的基石。



* **`NeuralFieldProgram` (类)**

  * **作用**：`PromptProgram` 的子类，专门用于增强与“神经场”上下文管理系统的集成。

  * **核心属性**：

    * `neural_field`：一个神经场实例，可以是外部传入，也可以根据 `field_params` 在内部创建（如 `ResidueEnhancedNeuralField` 或一个简化的 `BasicNeuralField`）。

  * **核心方法**：

    * `_create_basic_neural_field(params)`：一个简化的 `BasicNeuralField` 实现，用于演示神经场的 `inject`（注入信息）、`decay`（信息衰减）和 `get_context_representation`（获取场表示）等基本操作。

    * `add_resonance_step(description, patterns)`：添加一个指示 LLM 在神经场中与特定模式进行“共振”的步骤，并通过 `inject` 将相关模式送入场中。

    * `add_attractor(pattern, strength)`：向神经场中添加一个“吸引子”，用于塑造场的语义地形和引导信息流动。

    * `execute(input_data, max_tokens)` (重写)：在程序执行前，先调用神经场的 `decay()` 方法模拟信息随时间衰减；执行结束后，尝试测量并记录神经场的各项指标（如稳定度、一致性）。

    * `_measure_field_metrics()`：尝试获取神经场的各种性能指标。

  * **工程关系**：将前一个代码段中定义的“神经场”概念具体化，使其能够作为 LLM 提示的动态、演化上下文，从而实现更高级的“记忆”和“理解”。



* **`ProtocolShellProgram` (类)**

  * **作用**：`PromptProgram` 的子类，用于集成“协议壳”（Protocol Shells）。

  * **核心属性**：

    * `protocol`：一个字典，代表加载的协议壳定义（通常来自类似 Pareto-lang 的 YAML 或 JSON）。

  * **核心方法**：

    * `_generate_steps_from_protocol()`：根据 `protocol` 中定义的 `process` 步骤，自动生成 `PromptProgram` 的 `ProgramStep` 列表。

    * `format()` (重写)：在标准的提示程序格式化基础上，将协议壳本身的结构（包括 `intent`、`input`、`process`、`output` 等）也格式化并包含在 LLM 提示的开头，明确告知 LLM 任务的结构化定义。

    * `_format_protocol()`：将协议壳的字典结构转换为类似代码的字符串表示。

    * `execute(input_data, max_tokens)` (重写)：在执行前，更新协议中 `<current_input>` 或 `<input>` 占位符为实际的用户输入。

    * `extract_output(response)`：根据协议中定义的 `output` 模式，尝试从 LLM 的原始响应文本中解析出结构化的输出数据（例如，JSON 格式）。

  * **工程关系**：弥合了声明式任务定义（协议壳）与可执行提示程序之间的鸿沟，允许开发者通过高层次的协议定义来抽象和自动化 LLM 任务的执行流程。这与之前提到 "Field Protocol Shells - Reusable templates for implementing field protocols" 的目标高度一致。



## 3）代码的运行示例



该代码段自带了三个独立的运行示例，分别展示了 `PromptProgram` 及其两个扩展子类的用法。这些示例通过 `MockModel` 来模拟 LLM 的行为，避免了对真实 LLM API 的依赖。



### 示例1: `basic_program_example()` - 基础提示程序



**目的**：演示如何创建最简单的 `PromptProgram`，添加一系列指令步骤，并执行它。它模拟了 LLM 逐步解决数学应用题的过程。



**执行过程**：



1. 创建一个 `MockModel`，其 `generate` 方法被硬编码为返回一个预设的、分步解答数学问题的字符串。

2. 实例化 `PromptProgram`，描述其目的为“逐步解决数学应用题”。

3) 通过 `add_step()` 方法添加四个核心推理步骤：

   * 解析问题识别变量。

   * 建立方程。

   * 求解未知变量。

   * 验证解决方案。

4) 调用 `program.format()` 打印出结构化后的提示程序，展示其“代码”形式。

5. 调用 `program.execute()` 并传入一个数学应用题字符串。`PromptProgram` 会将格式化后的程序和输入发送给 `MockModel`，后者返回预设的解答。

6. 调用 `program.execute_with_trace()` 来演示如何从 LLM 的响应中解析出每一步的推理和结果。



**输出示例**：





### 示例2: `neural_field_program_example()` - 神经场提示程序



**目的**：演示 `NeuralFieldProgram` 如何与一个简化的神经场集成，从而在 LLM 推理过程中维护一个动态、演化的上下文。



**执行过程**：



1. 创建一个 `MockModel`，其 `generate` 方法返回一个关于研究方向建议的模拟响应。

2. 实例化 `NeuralFieldProgram`，并提供 `field_params` 来初始化一个 `BasicNeuralField`（代码中简化的神经场模拟）。

3) 通过 `program.add_attractor()` 向神经场中添加几个“吸引子”（预设的语义模式），这些吸引子将影响场内信息的组织。

4) 添加常规的推理步骤，并通过 `program.add_resonance_step()` 添加一个特殊的共振步骤，该步骤会将特定的模式注入到神经场中，模拟信息在场中的活跃。

5. 调用 `program.format()` 打印出带有神经场状态（由 `BasicNeuralField` 的 `get_context_representation` 提供）的提示程序。

6. 调用 `program.execute()`。在执行前，神经场会模拟衰减 (`decay()`)。执行后，程序会尝试测量场的指标，模拟信息在神经场中动态变化的效果。



**输出示例**（部分，含模拟的日志输出）：





### 示例3: `protocol_shell_program_example()` - 协议壳提示程序



**目的**：演示 `ProtocolShellProgram` 如何根据一个结构化的“协议壳”定义（例如，从 YAML 文件加载的结构）自动生成提示程序，并从 LLM 响应中提取结构化输出。



**执行过程**：



1. 创建一个 `MockModel`，其 `generate` 方法返回一个模拟的论文摘要和结构化信息。

2. 定义一个 `protocol` 字典，模拟一个用于“简洁总结研究论文”的协议壳定义，包含 `intent`、`input`、`process`（处理步骤）、`output`（输出模式）等字段。

3) 实例化 `ProtocolShellProgram`，将 `protocol` 字典传入。该类的 `__init__` 会自动根据 `protocol` 的 `process` 部分生成 `ProgramStep`。

4) 调用 `program.format()` 打印出结构化后的提示程序，其中包含了协议壳本身的“代码”表示，明确告知 LLM 任务的结构和期望的输出格式。

5. 调用 `program.execute()` 并传入一篇模拟的论文简介。`ProtocolShellProgram` 会更新协议中的输入，然后将完整的提示发送给 `MockModel`。

6. 调用 `program.extract_output()`。此方法会根据协议中定义的 `output` 模式，尝试从 LLM 的响应中解析出 `summary`、`key_finding` 等结构化数据。



**输出示例**：





***



